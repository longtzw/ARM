# 第1章 ARM概述及基本编程模型

## 1.1 ARM处理器模式

ARM处理器共有7种运行模式，如表1.1所示。

**表1.1**

处理器模式                    |描述
------------------------------|-------------------------
用户模式(User)                |正常程序执行的模式
快速中断模式(FIQ)             |用于高速数据传输和处理
外部中断模式(IRQ)             |用于通常的中断处理
特权模式(Supervisor)          |供操作系统使用的一种保护模式
数据访问终止模式(Abort)       |用于虚拟存储及存储保护
未定义指令中止模式(Undefined) |用于支持通过软件仿真硬件的协处理器
系统模式(System)              |用于运行特权级的操作系统任务

除了用户模式之外的6种处理器模式称为特权模式。在这些模式下，程序可以访问所有的系统资源，也可以任意进行处理器模式切换。其中，除系统模式外，其它5种特权模式又称为异常模式。

大多数的用户程序运行在用户模式下。当需要进行处理器模式切换时应用程序可以产生异常处理，在异常处理中进行模式切换。

每一种异常模式中都有一组寄存器，供相应的异常处理程序使用，这样可以保证在进入异常模式时，用户模式下的寄存器不被破坏。

系统模式并不是通过异常进入的，它和用户模式具有完全一样的寄存器，但它可以访问所有的系统资源，它主要供操作系统使用。

## 1.2 ARM寄存器介绍

表1.2列出了各处理器模式下可见的寄存器情况。

**表1.2**

用户模式 | 系统模式 | 特权模式 | 中止模式 | 未定义指令模式 | 外部中断模式 | 快速中断模式
---------|----------|----------|----------|----------------|--------------|-------------
R0       |R0        |R0        |R0        |R0              |R0            |R0  
R1       |R1        |R1        |R1        |R1              |R1            |R1  
R2       |R2        |R2        |R2        |R2              |R2            |R2  
R3       |R3        |R3        |R3        |R3              |R3            |R3  
R4       |R4        |R4        |R4        |R4              |R4            |R4  
R5       |R5        |R5        |R5        |R5              |R5            |R5  
R6       |R6        |R6        |R6        |R6              |R6            |R6  
R7       |R7        |R7        |R7        |R7              |R7            |R7  
R8       |R8        |R8        |R8        |R8              |R8            |R8_fiq 
R9       |R9        |R9        |R9        |R9              |R9            |R9_fiq  
R10      |R10       |R10       |R10       |R10             |R10           |R10_fiq  
R11      |R11       |R11       |R11       |R11             |R11           |R11_fiq  
R12      |R12       |R12       |R12       |R12             |R12           |R12_fiq  
R13      |R13       |R13_svc   |R13_abt   |R13_und         |R13_irq       |R13_fiq  
R14      |R14       |R14_svc   |R14_abt   |R14_und         |R14_irq       |R14_fiq  
PC       |PC        |PC        |PC        |PC              |PC            |PC  
CPSR     |CPSR      |CPSR      |CPSR      |CPSR            |CPSR          |CPSR  
         |          |SPSR_svc  |SPSR_abt  |SPSR_und        |SPSR_irq      |SPSR_fiq

### 1.2.1 通用寄存器

通用寄存器可以分为下面3类：

- 未备份寄存器(The unbanked registers), R0~R7
- 备份寄存器(The banked registers), R8~R14
- 程序计数器PC, R15

R13在ARM中常用作堆栈指针，每一种异常模式拥有自己的物理R13。应用程序初始化它，使其指向该异常模式专用的栈地址。R14又被称为连接寄存器(Link Register, LR)。对于ARM指令集来说，PC指向当前指令的下面两条指令的地址，由于ARM指令是字节对齐的，PC值的第0位和第1位总是0。

### 1.2.2 程序状态寄存器

CPSR(当前程序状态寄存器)可以在任何处理器模式下被访问。它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。每一种处理器模式下都有一个专用的物理状态寄存器，称为SPSR(备份程序状态寄存器)。当特定的异常中断发生时，这个寄存器用于存放当前程序状态寄存器的内容。异常恢复时，可以用SPSR中保存的值来恢复CPSR。

## 1.3 ARM体系中的存储系统

### 1.3.1 ARM存储器格式

![大小端](http://img.hb.aicdn.com/0cc93b52d8b9cb168cb5fa861b83f44163537683c113-j4zh4H)

### 1.3.2 非对齐的存储访问

在ARM中，通常希望字单元的地址是字对其的(地址的低两位为00)，半字单元的地址是半字对齐的(地址最低位为0)。在存储访问中，如果存储单元的地址没有遵守上述的对齐规则，则称为非对其的存储访问操作。

#### 1.3.2.1 非对齐的指令预取操作

若ARM状态期间，写入到寄存器PC中的值非字对齐，或Thumb状态期间，写入寄存器PC中的值非半字对齐，则，要么执行指令的结果不可预知，要没地址值中最低位被忽略。若是后者，则由存储系统实现这种“忽略”。也就是说，这时该地址值原封不动地送回存储系统。

#### 1.3.2.2 非对齐数据访问操作

对于 Load/Store操作，如果是非对齐的数据访问操作，系统定义了下面3种可能的结果：

- 执行结果不可预知
- 访问(address AND 0xfffffffc)或(address AND 0xfffffffe)
- 忽略本次操作

# 第2章 ARM指令分类及其寻址方式

## 2.1 ARM指令集概要介绍

### 2.1.1 ARM指令的分类

ARM指令集可以分为跳转指令、数据处理指令、程序状态寄存器(PSR)传输指令、Load/Store指令、协处理器指令和异常中断产生指令6类。

### 2.1.2 ARM指令的一般编码格式

一条典型的ARM指令语法格式如下所示：

```
<opcode>{<cond>}{S} <Rd>,<Rn>,<shifter_operand>
```

其中：

- opcode 是指令助记符
- code 表示指令执行的条件
- S 决定指令的操作是否影响CPSR的值
- Rd 表示目标寄存器
- Rn 表示包含第1个操作数的寄存器
- shifter_operand 表示第2个操作数

## 2.2 ARM指令的寻址方式

### 2.2.1 数据处理指令的操作数的寻址方式

shifter_operand 通常有下面3种格式：

- 立即数方式(并不是每个32位的常数都是合法的立即数，immediate=immed_8循环右移(2*rotate_imm))
- 寄存器方式
- 寄存器移位方式，具体的移位(或循环移位)的方式有下面几种：
	+ ASR 算术右移
	+ LSL 逻辑左移
	+ LSR 逻辑右移
	+ ROR 循环右移
	+ RRX 扩展的循环右移

下面是一些寄存器移位方式的操作数示例：

```
MOV R0,R1,LSL #3         ;R0=R1*(2^3)
ADD R0,R1,LSL #3         ;R0=R1+R1*(2^3)
SUB R0,R1,R2,LSR #4      ;R0=R1-R2/(2^4)
MOV R0,R1,ROR R2         ;R0=R1循环右移R2位
```

### 2.2.2 字及无符号字节的Load/Store指令的寻址方式

Load 指令用于从内存中读取数据放入寄存器中；Store指令用于将寄存器中的数据保存到内存。

各种类型的Load/Store指令的寻址方式由两部分组成，基址寄存器+地址偏移量。基址寄存器可以为任何一个通用寄存器，地址偏移量可以有以下3种格式：

- 立即数
- 寄存器(值)
- 寄存器及一个移位常数，寄存器中的数值可以根据指令中的移位标志及移位常数作一定的移位操作，生成一个地址偏移量

# 第3章 ARM指令集介绍

## 3.1 ARM指令集

### 3.1.1 跳转指令

在ARM中有两种方式可以实现程序的跳转：一种是跳转指令；另一种是直接向PC寄存器中写入目标地址。后者可以实现在4GB的地址空间中任意跳转(长跳转)。

ARM的跳转指令可以从当前指令向前或向后的32MB的地址空间跳转。包含以下4种：

- B 跳转指令
- BL 带返回的跳转指令
- BLX 带返回和状态切换的跳转指令
- BX 带状态切换的跳转指令

**示例**

```
B Lable    ; 程序跳转到标号Lable处执行
BCC Lable  ; 当CPSR寄存器中的C条件标志位为1时，程序跳转到标号Lable处执行
BL func_1  ; 程序跳转到子程序func_1处执行，同时将当前PC值保存到LR中
```
### 3.1.2 数据处理指令

数据处理指令可大致分为3类：数据传送指令、算术逻辑运算指令、比较指令

- MOV 数据传送指令
- MVN 数据求反传送指令
- CMP 比较指令
- CMP 基于相反数的比较指令
- TST 位测试指令
- TEQ 相等测试指令
- ADD 加法指令
- SUB 减法指令
- RSB 逆向减法指令
- ADC 带位加法指令
- SBC 带位减法指令
- RSC 带位逆向减法指令
- AND 逻辑与操作指令
- BIC 位清除指令
- EOR 逻辑异或操作指令
- ORR 逻辑或操作指令

```
MOV{<cond>}{S} <Rd>, <shifter_operand>
```
S决定指令操作是否影响CPSR中条件标志位的值。当有S时指令更新CPSR中条件标志位的值；没有时则不更新。

```
MVN{<cond>}{S} <Rd>, <shifter_operand>
```
MVN指令将<shifter_operand>表示的数据的反码传送到目标寄存器<Rd>中，并根据操作结果更新CPSR中相应的条件标志位。
